[{"C:\\Users\\Yebba\\Desktop\\dglnfts\\DGLNFT Candy Machine\\LEGENDARIES\\Candy-Machine-V3-UI\\pages\\index.tsx":"1","C:\\Users\\Yebba\\Desktop\\dglnfts\\DGLNFT Candy Machine\\LEGENDARIES\\Candy-Machine-V3-UI\\pages\\_app.tsx":"2","C:\\Users\\Yebba\\Desktop\\dglnfts\\DGLNFT Candy Machine\\LEGENDARIES\\Candy-Machine-V3-UI\\src\\borsh\\mintCounter.ts":"3","C:\\Users\\Yebba\\Desktop\\dglnfts\\DGLNFT Candy Machine\\LEGENDARIES\\Candy-Machine-V3-UI\\src\\config.ts":"4","C:\\Users\\Yebba\\Desktop\\dglnfts\\DGLNFT Candy Machine\\LEGENDARIES\\Candy-Machine-V3-UI\\src\\helpers\\index.ts":"5","C:\\Users\\Yebba\\Desktop\\dglnfts\\DGLNFT Candy Machine\\LEGENDARIES\\Candy-Machine-V3-UI\\src\\helpers\\MerkleTree.ts":"6","C:\\Users\\Yebba\\Desktop\\dglnfts\\DGLNFT Candy Machine\\LEGENDARIES\\Candy-Machine-V3-UI\\src\\Home.tsx":"7","C:\\Users\\Yebba\\Desktop\\dglnfts\\DGLNFT Candy Machine\\LEGENDARIES\\Candy-Machine-V3-UI\\src\\hooks\\types.ts":"8","C:\\Users\\Yebba\\Desktop\\dglnfts\\DGLNFT Candy Machine\\LEGENDARIES\\Candy-Machine-V3-UI\\src\\hooks\\useCandyMachineV3.tsx":"9","C:\\Users\\Yebba\\Desktop\\dglnfts\\DGLNFT Candy Machine\\LEGENDARIES\\Candy-Machine-V3-UI\\src\\hooks\\utils.ts":"10","C:\\Users\\Yebba\\Desktop\\dglnfts\\DGLNFT Candy Machine\\LEGENDARIES\\Candy-Machine-V3-UI\\src\\main.tsx":"11","C:\\Users\\Yebba\\Desktop\\dglnfts\\DGLNFT Candy Machine\\LEGENDARIES\\Candy-Machine-V3-UI\\src\\MintButton.tsx":"12","C:\\Users\\Yebba\\Desktop\\dglnfts\\DGLNFT Candy Machine\\LEGENDARIES\\Candy-Machine-V3-UI\\src\\MultiMintButton.tsx":"13","C:\\Users\\Yebba\\Desktop\\dglnfts\\DGLNFT Candy Machine\\LEGENDARIES\\Candy-Machine-V3-UI\\src\\NftsModal.tsx":"14","C:\\Users\\Yebba\\Desktop\\dglnfts\\DGLNFT Candy Machine\\LEGENDARIES\\Candy-Machine-V3-UI\\src\\styles.ts":"15","C:\\Users\\Yebba\\Desktop\\dglnfts\\DGLNFT Candy Machine\\LEGENDARIES\\Candy-Machine-V3-UI\\src\\utils.ts":"16"},{"size":338,"mtime":1673211249386,"results":"17","hashOfConfig":"18"},{"size":229,"mtime":1673211249385,"results":"19","hashOfConfig":"18"},{"size":625,"mtime":1673211249395,"results":"20","hashOfConfig":"18"},{"size":696,"mtime":1676274015171,"results":"21","hashOfConfig":"18"},{"size":31,"mtime":1673211249396,"results":"22","hashOfConfig":"18"},{"size":3348,"mtime":1673211249396,"results":"23","hashOfConfig":"18"},{"size":14082,"mtime":1676275691055,"results":"24","hashOfConfig":"18"},{"size":2758,"mtime":1673211249396,"results":"25","hashOfConfig":"18"},{"size":13575,"mtime":1673211249396,"results":"26","hashOfConfig":"18"},{"size":15658,"mtime":1675139674225,"results":"27","hashOfConfig":"18"},{"size":2170,"mtime":1673211249397,"results":"28","hashOfConfig":"18"},{"size":3240,"mtime":1673211249394,"results":"29","hashOfConfig":"18"},{"size":9238,"mtime":1676275211699,"results":"30","hashOfConfig":"18"},{"size":4479,"mtime":1675139634948,"results":"31","hashOfConfig":"18"},{"size":14471,"mtime":1673511503484,"results":"32","hashOfConfig":"18"},{"size":139,"mtime":1673211249397,"results":"33","hashOfConfig":"18"},{"filePath":"34","messages":"35","suppressedMessages":"36","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},"1d0roya",{"filePath":"37","messages":"38","suppressedMessages":"39","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"40","messages":"41","suppressedMessages":"42","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"43","messages":"44","suppressedMessages":"45","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"46","messages":"47","suppressedMessages":"48","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"49","messages":"50","suppressedMessages":"51","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"52","messages":"53","suppressedMessages":"54","errorCount":0,"fatalErrorCount":0,"warningCount":6,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},{"filePath":"55","messages":"56","suppressedMessages":"57","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"58","messages":"59","suppressedMessages":"60","errorCount":0,"fatalErrorCount":0,"warningCount":5,"fixableErrorCount":0,"fixableWarningCount":0,"source":"61"},{"filePath":"62","messages":"63","suppressedMessages":"64","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"65","messages":"66","suppressedMessages":"67","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"68","messages":"69","suppressedMessages":"70","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"71","messages":"72","suppressedMessages":"73","errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"74"},{"filePath":"75","messages":"76","suppressedMessages":"77","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"78","messages":"79","suppressedMessages":"80","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"81","messages":"82","suppressedMessages":"83","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},"C:\\Users\\Yebba\\Desktop\\dglnfts\\DGLNFT Candy Machine\\LEGENDARIES\\Candy-Machine-V3-UI\\pages\\index.tsx",[],[],"C:\\Users\\Yebba\\Desktop\\dglnfts\\DGLNFT Candy Machine\\LEGENDARIES\\Candy-Machine-V3-UI\\pages\\_app.tsx",[],[],"C:\\Users\\Yebba\\Desktop\\dglnfts\\DGLNFT Candy Machine\\LEGENDARIES\\Candy-Machine-V3-UI\\src\\borsh\\mintCounter.ts",[],[],"C:\\Users\\Yebba\\Desktop\\dglnfts\\DGLNFT Candy Machine\\LEGENDARIES\\Candy-Machine-V3-UI\\src\\config.ts",[],[],"C:\\Users\\Yebba\\Desktop\\dglnfts\\DGLNFT Candy Machine\\LEGENDARIES\\Candy-Machine-V3-UI\\src\\helpers\\index.ts",[],[],"C:\\Users\\Yebba\\Desktop\\dglnfts\\DGLNFT Candy Machine\\LEGENDARIES\\Candy-Machine-V3-UI\\src\\helpers\\MerkleTree.ts",[],[],"C:\\Users\\Yebba\\Desktop\\dglnfts\\DGLNFT Candy Machine\\LEGENDARIES\\Candy-Machine-V3-UI\\src\\Home.tsx",["84","85","86","87","88","89"],[],"C:\\Users\\Yebba\\Desktop\\dglnfts\\DGLNFT Candy Machine\\LEGENDARIES\\Candy-Machine-V3-UI\\src\\hooks\\types.ts",[],[],"C:\\Users\\Yebba\\Desktop\\dglnfts\\DGLNFT Candy Machine\\LEGENDARIES\\Candy-Machine-V3-UI\\src\\hooks\\useCandyMachineV3.tsx",["90","91","92","93","94"],[],"import {\r\n  callCandyGuardRouteBuilder,\r\n  CandyMachine,\r\n  getMerkleProof,\r\n  getMerkleTree,\r\n  IdentitySigner,\r\n  Metadata,\r\n  Metaplex,\r\n  mintFromCandyMachineBuilder,\r\n  Nft,\r\n  NftWithToken,\r\n  PublicKey,\r\n  Sft,\r\n  SftWithToken,\r\n  TransactionBuilder,\r\n  walletAdapterIdentity,\r\n} from \"@metaplex-foundation/js\";\r\nimport { useConnection, useWallet } from \"@solana/wallet-adapter-react\";\r\n\r\nimport { TOKEN_PROGRAM_ID } from \"@solana/spl-token\";\r\nimport React from \"react\";\r\nimport { MerkleTree } from \"merkletreejs\";\r\nimport {\r\n  AllowLists,\r\n  CustomCandyGuardMintSettings,\r\n  GuardGroup,\r\n  GuardGroupStates,\r\n  NftPaymentMintSettings,\r\n  ParsedPricesForUI,\r\n  Token,\r\n} from \"./types\";\r\nimport {\r\n  fetchMintLimit,\r\n  guardToPaymentUtil,\r\n  mergeGuards,\r\n  parseGuardGroup,\r\n  parseGuardStates,\r\n} from \"./utils\";\r\n\r\nexport default function useCandyMachineV3(\r\n  candyMachineId: PublicKey | string,\r\n  candyMachineOpts: {\r\n    allowLists?: AllowLists;\r\n  } = {}\r\n) {\r\n  const { connection } = useConnection();\r\n  const wallet = useWallet();\r\n  const [guardsAndGroups, setGuardsAndGroups] = React.useState<{\r\n    default?: GuardGroup;\r\n    [k: string]: GuardGroup;\r\n  }>({});\r\n\r\n  const [status, setStatus] = React.useState({\r\n    candyMachine: false,\r\n    guardGroups: false,\r\n    minting: false,\r\n    initialFetchGuardGroupsDone: false,\r\n  });\r\n\r\n  const [balance, setBalance] = React.useState(0);\r\n  const [allTokens, setAllTokens] = React.useState<Token[]>([]);\r\n  const [nftHoldings, setNftHoldings] = React.useState<Metadata[]>([]);\r\n\r\n  const tokenHoldings = React.useMemo<Token[]>(() => {\r\n    if (!nftHoldings?.length || !allTokens?.length) return [];\r\n    return allTokens.filter(\r\n      (x) => !nftHoldings.find((y) => x.mint.equals(y.address))\r\n    );\r\n  }, [nftHoldings, allTokens]);\r\n\r\n  const [candyMachine, setCandyMachine] = React.useState<CandyMachine>(null);\r\n  const [items, setItems] = React.useState({\r\n    available: 0,\r\n    remaining: 0,\r\n    redeemed: 0,\r\n  });\r\n\r\n  const mx = React.useMemo(\r\n    () => connection && Metaplex.make(connection),\r\n    [connection]\r\n  );\r\n\r\n  const proofMemo = React.useMemo(() => {\r\n    if (!candyMachineOpts.allowLists?.length) {\r\n      return {\r\n        merkles: {},\r\n        verifyProof() {\r\n          return true;\r\n        },\r\n      };\r\n    }\r\n    if (!wallet.publicKey) {\r\n      return {\r\n        merkles: {},\r\n        verifyProof() {\r\n          return false;\r\n        },\r\n      };\r\n    }\r\n    const merkles: { [k: string]: { tree: MerkleTree; proof: Uint8Array[] } } =\r\n      candyMachineOpts.allowLists.reduce(\r\n        (prev, { groupLabel, list }) =>\r\n          Object.assign(prev, {\r\n            [groupLabel]: {\r\n              tree: getMerkleTree(list),\r\n              proof: getMerkleProof(list, wallet.publicKey.toString()),\r\n            },\r\n          }),\r\n        {}\r\n      );\r\n    const verifyProof = (\r\n      merkleRoot: Uint8Array | string,\r\n      label = \"default\"\r\n    ) => {\r\n      let merkle = merkles[label];\r\n      if (!merkle) return;\r\n      const verifiedProof = !!merkle.proof.length;\r\n      const compareRoot = merkle.tree.getRoot().equals(Buffer.from(merkleRoot));\r\n      return verifiedProof && compareRoot;\r\n    };\r\n    return {\r\n      merkles,\r\n      verifyProof,\r\n    };\r\n  }, [wallet.publicKey, candyMachineOpts.allowLists?.length]);\r\n\r\n  const fetchCandyMachine = React.useCallback(async () => {\r\n    return await mx.candyMachines().findByAddress({\r\n      address: new PublicKey(candyMachineId),\r\n    });\r\n  }, [candyMachineId]);\r\n\r\n  const refresh = React.useCallback(async () => {\r\n    if (!wallet.publicKey) throw new Error(\"Wallet not loaded yet!\");\r\n\r\n    setStatus((x) => ({ ...x, candyMachine: true }));\r\n    await fetchCandyMachine()\r\n      .then((cndy) => {\r\n        setCandyMachine(cndy);\r\n        setItems({\r\n          available: cndy.itemsAvailable.toNumber(),\r\n          remaining: cndy.itemsRemaining.toNumber(),\r\n          redeemed: cndy.itemsMinted.toNumber(),\r\n        });\r\n\r\n        return cndy;\r\n      })\r\n      .catch((e) => console.error(\"Error while fetching candy machine\", e))\r\n      .finally(() => setStatus((x) => ({ ...x, candyMachine: false })));\r\n  }, [fetchCandyMachine, wallet.publicKey]);\r\n\r\n  const mint = React.useCallback(\r\n    async (\r\n      quantityString: number = 1,\r\n      opts: {\r\n        groupLabel?: string;\r\n        nftGuards?: NftPaymentMintSettings[];\r\n      } = {}\r\n    ) => {\r\n      if (!guardsAndGroups[opts.groupLabel || \"default\"])\r\n        throw new Error(\"Unknown guard group label\");\r\n\r\n      const allowList = opts.groupLabel &&\r\n        proofMemo.merkles[opts.groupLabel] && {\r\n          proof: proofMemo.merkles[opts.groupLabel].proof,\r\n        };\r\n\r\n      let nfts: (Sft | SftWithToken | Nft | NftWithToken)[] = [];\r\n      try {\r\n        if (!candyMachine) throw new Error(\"Candy Machine not loaded yet!\");\r\n\r\n        setStatus((x) => ({\r\n          ...x,\r\n          minting: true,\r\n        }));\r\n\r\n        const transactionBuilders: TransactionBuilder[] = [];\r\n        if (allowList) {\r\n          if (!proofMemo.merkles[opts.groupLabel || \"default\"].proof.length)\r\n            throw new Error(\"User is not in allowed list\");\r\n\r\n          transactionBuilders.push(\r\n            callCandyGuardRouteBuilder(mx, {\r\n              candyMachine,\r\n              guard: \"allowList\",\r\n              group: opts.groupLabel,\r\n              settings: {\r\n                path: \"proof\",\r\n                merkleProof:\r\n                  proofMemo.merkles[opts.groupLabel || \"default\"].proof,\r\n              },\r\n            })\r\n          );\r\n        }\r\n        for (let index = 0; index < quantityString; index++) {\r\n          transactionBuilders.push(\r\n            await mintFromCandyMachineBuilder(mx, {\r\n              candyMachine,\r\n              collectionUpdateAuthority: candyMachine.authorityAddress, // mx.candyMachines().pdas().authority({candyMachine: candyMachine.address})\r\n              group: opts.groupLabel,\r\n              guards: {\r\n                nftBurn: opts.nftGuards && opts.nftGuards[index]?.burn,\r\n                nftPayment: opts.nftGuards && opts.nftGuards[index]?.payment,\r\n                nftGate: opts.nftGuards && opts.nftGuards[index]?.gate,\r\n                allowList,\r\n              },\r\n            })\r\n          );\r\n        }\r\n        const blockhash = await mx.rpc().getLatestBlockhash();\r\n\r\n        const transactions = transactionBuilders.map((t) =>\r\n          t.toTransaction(blockhash)\r\n        );\r\n        const signers: { [k: string]: IdentitySigner } = {};\r\n        transactions.forEach((tx, i) => {\r\n          tx.feePayer = wallet.publicKey;\r\n          tx.recentBlockhash = blockhash.blockhash;\r\n          transactionBuilders[i].getSigners().forEach((s) => {\r\n            if (\"signAllTransactions\" in s) signers[s.publicKey.toString()] = s;\r\n            else if (\"secretKey\" in s) tx.partialSign(s);\r\n            // @ts-ignore\r\n            else if (\"_signer\" in s) tx.partialSign(s._signer);\r\n          });\r\n        });\r\n        let signedTransactions = transactions;\r\n\r\n        for (let signer in signers) {\r\n          await signers[signer].signAllTransactions(transactions);\r\n        }\r\n        if (allowList) {\r\n          const allowListCallGuardRouteTx = signedTransactions.shift();\r\n          const allowListCallGuardRouteTxBuilder = transactionBuilders.shift();\r\n          await mx.rpc().sendAndConfirmTransaction(allowListCallGuardRouteTx, {\r\n            commitment: \"processed\",\r\n          });\r\n        }\r\n        const output = await Promise.all(\r\n          signedTransactions.map((tx, i) => {\r\n            return mx\r\n              .rpc()\r\n              .sendAndConfirmTransaction(tx, { commitment: \"finalized\" })\r\n              .then((tx) => ({\r\n                ...tx,\r\n                context: transactionBuilders[i].getContext() as any,\r\n              }));\r\n          })\r\n        );\r\n        nfts = await Promise.all(\r\n          output.map(({ context }) =>\r\n            mx\r\n              .nfts()\r\n              .findByMint({\r\n                mintAddress: context.mintSigner.publicKey,\r\n                tokenAddress: context.tokenAddress,\r\n              })\r\n              .catch((e) => null)\r\n          )\r\n        );\r\n        Object.values(guardsAndGroups).forEach((guards) => {\r\n          if (guards.mintLimit?.mintCounter)\r\n            guards.mintLimit.mintCounter.count += nfts.length;\r\n        });\r\n        // setItems((x) => ({\r\n        //   ...x,\r\n        //   remaining: x.remaining - nfts.length,\r\n        //   redeemed: x.redeemed + nfts.length,\r\n        // }));\r\n      } catch (error: any) {\r\n        let message = error.msg || \"Minting failed! Please try again!\";\r\n        if (!error.msg) {\r\n          if (!error.message) {\r\n            message = \"Transaction Timeout! Please try again.\";\r\n          } else if (error.message.indexOf(\"0x138\")) {\r\n          } else if (error.message.indexOf(\"0x137\")) {\r\n            message = `SOLD OUT!`;\r\n          } else if (error.message.indexOf(\"0x135\")) {\r\n            message = `Insufficient funds to mint. Please fund your wallet.`;\r\n          }\r\n        } else {\r\n          if (error.code === 311) {\r\n            message = `SOLD OUT!`;\r\n          } else if (error.code === 312) {\r\n            message = `Minting period hasn't started yet.`;\r\n          }\r\n        }\r\n        console.error(error);\r\n        throw new Error(message);\r\n      } finally {\r\n        setStatus((x) => ({ ...x, minting: false }));\r\n        refresh();\r\n        return nfts.filter((a) => a);\r\n      }\r\n    },\r\n    [candyMachine, guardsAndGroups, mx, wallet?.publicKey, proofMemo, refresh]\r\n  );\r\n\r\n  React.useEffect(() => {\r\n    if (!mx || !wallet.publicKey) return;\r\n    console.log(\"useEffact([mx, wallet.publicKey])\");\r\n    mx.use(walletAdapterIdentity(wallet));\r\n\r\n    mx.rpc()\r\n      .getBalance(wallet.publicKey)\r\n      .then((x) => x.basisPoints.toNumber())\r\n      .then(setBalance)\r\n      .catch((e) => console.error(\"Error to fetch wallet balance\", e));\r\n\r\n    mx.nfts()\r\n      .findAllByOwner({\r\n        owner: wallet.publicKey,\r\n      })\r\n      .then((x) =>\r\n        setNftHoldings(x.filter((a) => a.model == \"metadata\") as any)\r\n      )\r\n      .catch((e) => console.error(\"Failed to fetch wallet nft holdings\", e));\r\n\r\n    (async (walletAddress: PublicKey): Promise<Token[]> => {\r\n      const tokenAccounts = (\r\n        await connection.getParsedTokenAccountsByOwner(walletAddress, {\r\n          programId: TOKEN_PROGRAM_ID,\r\n        })\r\n      ).value.filter(\r\n        (x) => parseInt(x.account.data.parsed.info.tokenAmount.amount) > 1\r\n      );\r\n\r\n      return tokenAccounts.map((x) => ({\r\n        mint: new PublicKey(x.account.data.parsed.info.mint),\r\n        balance: parseInt(x.account.data.parsed.info.tokenAmount.amount),\r\n        decimals: x.account.data.parsed.info.tokenAmount.decimals,\r\n      }));\r\n    })(wallet.publicKey).then(setAllTokens);\r\n  }, [mx, wallet.publicKey]);\r\n\r\n  React.useEffect(() => {\r\n    refresh().catch((e) =>\r\n      console.error(\"Error while fetching candy machine\", e)\r\n    );\r\n  }, [refresh]);\r\n\r\n  React.useEffect(() => {\r\n    const walletAddress = wallet.publicKey;\r\n    if (!walletAddress || !candyMachine) return;\r\n    console.log(\r\n      \"useEffact([mx, wallet, nftHoldings, proofMemo, candyMachine])\"\r\n    );\r\n\r\n    (async () => {\r\n      const guards = {\r\n        default: await parseGuardGroup(\r\n          {\r\n            guards: candyMachine.candyGuard.guards,\r\n            candyMachine,\r\n            nftHoldings,\r\n            verifyProof: proofMemo.verifyProof,\r\n            walletAddress,\r\n          },\r\n          mx\r\n        ),\r\n      };\r\n      await Promise.all(\r\n        candyMachine.candyGuard.groups.map(async (x) => {\r\n          guards[x.label] = await parseGuardGroup(\r\n            {\r\n              guards: mergeGuards([candyMachine.candyGuard.guards, x.guards]),\r\n              label: x.label,\r\n              candyMachine,\r\n              nftHoldings,\r\n              verifyProof: proofMemo.verifyProof,\r\n              walletAddress,\r\n            },\r\n            mx\r\n          );\r\n        })\r\n      );\r\n      setGuardsAndGroups(guards);\r\n    })();\r\n  }, [wallet.publicKey, nftHoldings, proofMemo, candyMachine]);\r\n\r\n  const prices = React.useMemo((): {\r\n    default?: ParsedPricesForUI;\r\n    [k: string]: ParsedPricesForUI;\r\n  } => {\r\n    // if (!status.initialFetchGuardGroupsDone) return {};\r\n    // const prices = {\r\n    // };\r\n    return Object.entries(guardsAndGroups).reduce(\r\n      (groupPayments, [label, guards]) => {\r\n        // console.log(label, guards);\r\n        return Object.assign(groupPayments, {\r\n          [label]: guardToPaymentUtil(guards),\r\n        });\r\n      },\r\n      {}\r\n    );\r\n  }, [guardsAndGroups]);\r\n\r\n  const guardStates = React.useMemo((): {\r\n    default?: GuardGroupStates;\r\n    [k: string]: GuardGroupStates;\r\n  } => {\r\n    return Object.entries(guardsAndGroups).reduce(\r\n      (groupPayments, [label, guards]) =>\r\n        Object.assign(groupPayments, {\r\n          [label]: parseGuardStates({\r\n            guards: guards,\r\n            candyMachine,\r\n            walletAddress: wallet.publicKey,\r\n            tokenHoldings,\r\n            balance,\r\n          }),\r\n        }),\r\n      {}\r\n    );\r\n  }, [guardsAndGroups, tokenHoldings, balance]);\r\n\r\n  React.useEffect(() => {\r\n    console.log({ guardsAndGroups, guardStates, prices });\r\n  }, [guardsAndGroups, guardStates, prices]);\r\n\r\n  return {\r\n    candyMachine,\r\n    guards: guardsAndGroups,\r\n    guardStates,\r\n    status,\r\n    items,\r\n    merkles: proofMemo.merkles,\r\n    prices,\r\n    mint,\r\n    refresh,\r\n  };\r\n}\r\n","C:\\Users\\Yebba\\Desktop\\dglnfts\\DGLNFT Candy Machine\\LEGENDARIES\\Candy-Machine-V3-UI\\src\\hooks\\utils.ts",[],[],"C:\\Users\\Yebba\\Desktop\\dglnfts\\DGLNFT Candy Machine\\LEGENDARIES\\Candy-Machine-V3-UI\\src\\main.tsx",[],[],"C:\\Users\\Yebba\\Desktop\\dglnfts\\DGLNFT Candy Machine\\LEGENDARIES\\Candy-Machine-V3-UI\\src\\MintButton.tsx",[],[],"C:\\Users\\Yebba\\Desktop\\dglnfts\\DGLNFT Candy Machine\\LEGENDARIES\\Candy-Machine-V3-UI\\src\\MultiMintButton.tsx",["95","96"],[],"import { CircularProgress } from \"@material-ui/core\";\r\nimport Button from \"@material-ui/core/Button\";\r\nimport { CandyMachine } from \"@metaplex-foundation/js\";\r\nimport { useEffect, useMemo, useRef, useState } from \"react\";\r\nimport styled from \"styled-components\";\r\nimport { useConnection, useWallet } from \"@solana/wallet-adapter-react\";\r\nimport { PublicKey } from \"@solana/web3.js\";\r\nimport { GatewayStatus, useGateway } from \"@civic/solana-gateway-react\";\r\nimport { GuardGroupStates, ParsedPricesForUI, PaymentRequired } from \"./hooks/types\";\r\n\r\nexport const CTAButton = styled(Button)`\r\n  display: inline-block !important;\r\n  margin: 10px auto !important;\r\n  background-color: #fff !important;\r\n  color: #000 !important;\r\n  min-width: 258px !important;\r\n  font-size: 1em !important;\r\n  font-family: \"Patrick Hand\", cursive;\r\n  font-weight: bold !important;\r\n`;\r\n\r\nexport const Minus = styled.button`\r\n  font-size: 2em;\r\n  padding: 25px 35px;\r\n  font-weight: bold;\r\n  line-height: 0.5px;\r\n  color: #000;\r\n  background: #fff;\r\n  box-shadow: 0px 3px 5px -1px rgb(0 0 0 / 20%),\r\n    0px 6px 10px 0px rgb(0 0 0 / 14%), 0px 1px 18px 0px rgb(0 0 0 / 12%);\r\n  border: 0;\r\n  border-radius: 5px;\r\n  box-sizing: border-box;\r\n  font-family: \"Patrick Hand\", cursive;\r\n  vertical-align: middle;\r\n  transition: all linear 0.3s;\r\n\r\n  :hover {\r\n    border: none;\r\n    outline: none !important;\r\n    background: #d09a69;\r\n  }\r\n  :not(disabled) {\r\n    cursor: pointer;\r\n  }\r\n\r\n  :not(disabled):hover {\r\n    outline: 1px solid var(--title-text-color);\r\n  }\r\n`;\r\n\r\nexport const Plus = styled(Minus)`\r\n  margin-left: 0;\r\n`;\r\n\r\nexport const NumericField = styled.input`\r\n  font-size: 2em !important;\r\n  padding: 0;\r\n  vertical-align: middle;\r\n  background-color: var(--main-text-color);\r\n  box-shadow: 0px 3px 5px -1px rgb(0 0 0 / 20%),\r\n    0px 6px 10px 0px rgb(0 0 0 / 14%), 0px 1px 18px 0px rgb(0 0 0 / 12%);\r\n  box-sizing: border-box;\r\n  font-family: \"Patrick Hand\", cursive;\r\n  font-weight: 500;\r\n  line-height: 1px;\r\n  border: none;\r\n  text-align: center;\r\n  border-radius: 5px;\r\n  transition: all 0.4s ease;\r\n  -moz-appearance: textfield;\r\n  -webkit-appearance: none;\r\n  margin: 0 10px;\r\n\r\n  :hover,\r\n  :focus {\r\n    box-shadow: 0px 3px 5px -1px rgb(0 0 0 / 40%),\r\n      0px 6px 10px 0px rgb(0 0 0 / 34%), 0px 1px 18px 0px rgb(0 0 0 / 32%);\r\n  }\r\n\r\n  ::-webkit-outer-spin-button,\r\n  ::-webkit-inner-spin-button {\r\n    -webkit-appearance: none;\r\n  }\r\n`;\r\nfunction usePrevious<T>(value: T): T | undefined {\r\n  const ref = useRef<T>();\r\n  useEffect(() => {\r\n    ref.current = value;\r\n  }, [value]);\r\n  return ref.current;\r\n}\r\nconst deepClone = (items: PaymentRequired[]) =>\r\n  items.map((item) => ({ ...item }));\r\nexport const MultiMintButton = ({\r\n  onMint,\r\n  candyMachine,\r\n  isMinting,\r\n  setIsMinting,\r\n  isEnded,\r\n  isActive,\r\n  isSoldOut,\r\n  prices,\r\n  guardStates,\r\n  gatekeeperNetwork,\r\n}: {\r\n  onMint: (quantityString: number) => Promise<void>;\r\n  candyMachine: CandyMachine | undefined;\r\n  isMinting: boolean;\r\n  setIsMinting: (val: boolean) => void;\r\n  isEnded: boolean;\r\n  isActive: boolean;\r\n  isSoldOut: boolean;\r\n  prices: ParsedPricesForUI;\r\n  guardStates: GuardGroupStates;\r\n  gatekeeperNetwork?: PublicKey;\r\n}) => {\r\n  const [loading, setLoading] = useState(false);\r\n\r\n  const [mintCount, setMintCount] = useState(1);\r\n  const { requestGatewayToken, gatewayStatus } = useGateway();\r\n  const [waitForActiveToken, setWaitForActiveToken] = useState(false);\r\n  const limit = useMemo(() => guardStates.canPayFor, [guardStates]);\r\n\r\n  const totalSolCost = useMemo(\r\n    () =>\r\n      prices\r\n        ? mintCount *\r\n          (prices.payment\r\n            .filter(({ kind }) => kind === \"sol\")\r\n            .reduce((a, { price }) => a + price, 0) +\r\n            0.012)\r\n        : 0.012,\r\n    [mintCount, prices]\r\n  );\r\n  const totalTokenCosts = useMemo((): PaymentRequired[] => {\r\n    if (!prices) return [];\r\n    const maxPriceHash: { [k: string]: number } = {};\r\n    const payment$burn$lenth = prices.payment.length + prices.burn.length;\r\n    let payments = deepClone(\r\n      prices.payment.concat(prices.burn).concat(prices.gate)\r\n    ).filter((price, index) => {\r\n      const cacheKey = price.mint?.toString();\r\n      if (![\"token\", \"nft\"].includes(price.kind)) return false;\r\n      const alreadyFound = !!maxPriceHash[cacheKey];\r\n      if (index < payment$burn$lenth) price.price *= mintCount;\r\n      price.price = maxPriceHash[cacheKey] = Math.max(\r\n        maxPriceHash[cacheKey] || 0,\r\n        price.price\r\n      );\r\n      return !alreadyFound;\r\n    });\r\n    return payments;\r\n  }, [mintCount, prices]);\r\n  const totalTokenCostsString = useMemo(() => {\r\n    return totalTokenCosts.reduce(\r\n      (text, price) => `${text} (You must also burn ONE random DGLNFT!)`,\r\n      \"\"\r\n    );\r\n  }, [totalTokenCosts]);\r\n\r\n  const previousGatewayStatus = usePrevious(gatewayStatus);\r\n  useEffect(() => {\r\n    const fromStates = [\r\n      GatewayStatus.NOT_REQUESTED,\r\n      GatewayStatus.REFRESH_TOKEN_REQUIRED,\r\n    ];\r\n    const invalidToStates = [...fromStates, GatewayStatus.UNKNOWN];\r\n    if (\r\n      fromStates.find((state) => previousGatewayStatus === state) &&\r\n      !invalidToStates.find((state) => gatewayStatus === state)\r\n    ) {\r\n      setIsMinting(true);\r\n    }\r\n    // console.log(\"change: \", GatewayStatus[gatewayStatus]);\r\n  }, [previousGatewayStatus, gatewayStatus, setIsMinting]);\r\n\r\n  useEffect(() => {\r\n    if (waitForActiveToken && gatewayStatus === GatewayStatus.ACTIVE) {\r\n      console.log(\"Minting after token active\");\r\n      setWaitForActiveToken(false);\r\n      onMint(mintCount);\r\n    }\r\n  }, [waitForActiveToken, gatewayStatus, onMint, mintCount]);\r\n\r\n  function incrementValue() {\r\n    var numericField = document.querySelector(\".mint-qty\") as HTMLInputElement;\r\n    if (numericField) {\r\n      var value = parseInt(numericField.value);\r\n      if (!isNaN(value) && value < 10) {\r\n        value++;\r\n        numericField.value = \"\" + value;\r\n        updateAmounts(value);\r\n      }\r\n    }\r\n  }\r\n\r\n  function decrementValue() {\r\n    var numericField = document.querySelector(\".mint-qty\") as HTMLInputElement;\r\n    if (numericField) {\r\n      var value = parseInt(numericField.value);\r\n      if (!isNaN(value) && value > 1) {\r\n        value--;\r\n        numericField.value = \"\" + value;\r\n        updateAmounts(value);\r\n      }\r\n    }\r\n  }\r\n\r\n  function updateMintCount(target: any) {\r\n    var value = parseInt(target.value);\r\n    if (!isNaN(value)) {\r\n      if (value > 10) {\r\n        value = 10;\r\n        target.value = \"\" + value;\r\n      } else if (value < 1) {\r\n        value = 1;\r\n        target.value = \"\" + value;\r\n      }\r\n      updateAmounts(value);\r\n    }\r\n  }\r\n\r\n  function updateAmounts(qty: number) {\r\n    setMintCount(qty);\r\n    // setTotalCost(Math.round(qty * (price + 0.012) * 1000) / 1000); // 0.012 = approx of account creation fees\r\n  }\r\n  const disabled = useMemo(\r\n    () =>\r\n      loading ||\r\n      isSoldOut ||\r\n      isMinting ||\r\n      isEnded ||\r\n      !isActive ||\r\n      mintCount > limit,\r\n    [loading, isSoldOut, isMinting, isEnded, !isActive]\r\n  );\r\n  return (\r\n    <div>\r\n      <div>\r\n        <Minus\r\n          disabled={disabled || mintCount <= 1}\r\n          onClick={() => decrementValue()}\r\n        >\r\n          <span style={{ marginTop: \"-5px !important\" }}>-</span>\r\n        </Minus>\r\n        <NumericField\r\n          disabled={disabled}\r\n          type=\"number\"\r\n          className=\"mint-qty\"\r\n          step={1}\r\n          min={1}\r\n          max={Math.min(limit, 10)}\r\n          value={mintCount}\r\n          onChange={(e) => updateMintCount(e.target as any)}\r\n        />\r\n        <Plus\r\n          disabled={disabled || limit <= mintCount}\r\n          onClick={() => incrementValue()}\r\n        >\r\n          +\r\n        </Plus>\r\n\r\n        <br />\r\n        <CTAButton\r\n          disabled={disabled}\r\n          onClick={async () => {\r\n            console.log(\"isActive gatekeeperNetwork\", {\r\n              isActive,\r\n              gatekeeperNetwork,\r\n            });\r\n            if (isActive && gatekeeperNetwork) {\r\n              if (gatewayStatus === GatewayStatus.ACTIVE) {\r\n                await onMint(mintCount);\r\n              } else {\r\n                setWaitForActiveToken(true);\r\n                await requestGatewayToken();\r\n              }\r\n            } else {\r\n              await onMint(mintCount);\r\n            }\r\n          }}\r\n          variant=\"contained\"\r\n        >\r\n          {!candyMachine ? (\r\n            \"CONNECTING...\"\r\n          ) : isSoldOut ? (\r\n            \"SOLD OUT\"\r\n          ) : isActive ? guardStates.messages.length ? (guardStates.messages[0]) : (\r\n            mintCount > limit ? (\r\n              \"LIMIT REACHED\"\r\n            ) : isMinting || loading ? (\r\n              <CircularProgress />\r\n            ) : (\r\n              \"MINT\"\r\n            )\r\n          ) : isEnded ? (\r\n            \"ENDED\"\r\n          ) : (\r\n            \"UNAVAILABLE\"\r\n          )}\r\n        </CTAButton>\r\n      </div>\r\n      {!isSoldOut && isActive && (\r\n        <h3>\r\n          Total Cost: {totalSolCost} SOL\r\n          {totalTokenCostsString}\r\n        </h3>\r\n      )}\r\n        {guardStates.messages?.map((m, i) => (\r\n          <p key={i}>{m}</p>\r\n        ))}\r\n    </div>\r\n  );\r\n};\r\n","C:\\Users\\Yebba\\Desktop\\dglnfts\\DGLNFT Candy Machine\\LEGENDARIES\\Candy-Machine-V3-UI\\src\\NftsModal.tsx",[],[],"C:\\Users\\Yebba\\Desktop\\dglnfts\\DGLNFT Candy Machine\\LEGENDARIES\\Candy-Machine-V3-UI\\src\\styles.ts",[],[],"C:\\Users\\Yebba\\Desktop\\dglnfts\\DGLNFT Candy Machine\\LEGENDARIES\\Candy-Machine-V3-UI\\src\\utils.ts",[],[],{"ruleId":"97","severity":1,"message":"98","line":189,"column":6,"nodeType":"99","endLine":189,"endColumn":19,"suggestions":"100"},{"ruleId":"97","severity":1,"message":"101","line":209,"column":6,"nodeType":"99","endLine":209,"endColumn":16,"suggestions":"102"},{"ruleId":"97","severity":1,"message":"103","line":253,"column":5,"nodeType":"99","endLine":253,"endColumn":34,"suggestions":"104"},{"ruleId":"105","severity":1,"message":"106","line":321,"column":19,"nodeType":"107","endLine":327,"endColumn":21},{"ruleId":"105","severity":1,"message":"106","line":410,"column":19,"nodeType":"107","endLine":416,"endColumn":21},{"ruleId":"105","severity":1,"message":"106","line":425,"column":19,"nodeType":"107","endLine":431,"endColumn":21},{"ruleId":"97","severity":1,"message":"108","line":125,"column":6,"nodeType":"99","endLine":125,"endColumn":61,"suggestions":"109"},{"ruleId":"97","severity":1,"message":"110","line":131,"column":6,"nodeType":"99","endLine":131,"endColumn":22,"suggestions":"111"},{"ruleId":"97","severity":1,"message":"112","line":333,"column":6,"nodeType":"99","endLine":333,"endColumn":28,"suggestions":"113"},{"ruleId":"97","severity":1,"message":"114","line":378,"column":6,"nodeType":"99","endLine":378,"endColumn":62,"suggestions":"115"},{"ruleId":"97","severity":1,"message":"116","line":415,"column":6,"nodeType":"99","endLine":415,"endColumn":47,"suggestions":"117"},{"ruleId":"97","severity":1,"message":"118","line":236,"column":5,"nodeType":"99","endLine":236,"endColumn":56,"suggestions":"119"},{"ruleId":"97","severity":1,"message":"120","line":236,"column":46,"nodeType":"121","endLine":236,"endColumn":55},"react-hooks/exhaustive-deps","React Hook useEffect has a missing dependency: 'throwConfetti'. Either include it or remove the dependency array.","ArrayExpression",["122"],"React Hook useCallback has an unnecessary dependency: 'confetti'. Either exclude it or remove the dependency array. Outer scope values like 'confetti' aren't valid dependencies because mutating them doesn't re-render the component.",["123"],"React Hook useCallback has missing dependencies: 'candyMachineV3' and 'guardLabel'. Either include them or remove the dependency array.",["124"],"@next/next/no-img-element","Do not use `<img>` element. Use `<Image />` from `next/image` instead. See: https://nextjs.org/docs/messages/no-img-element","JSXOpeningElement","React Hook React.useMemo has a missing dependency: 'candyMachineOpts.allowLists'. Either include it or remove the dependency array.",["125"],"React Hook React.useCallback has a missing dependency: 'mx'. Either include it or remove the dependency array.",["126"],"React Hook React.useEffect has missing dependencies: 'connection' and 'wallet'. Either include them or remove the dependency array.",["127"],"React Hook React.useEffect has a missing dependency: 'mx'. Either include it or remove the dependency array.",["128"],"React Hook React.useMemo has missing dependencies: 'candyMachine' and 'wallet.publicKey'. Either include them or remove the dependency array.",["129"],"React Hook useMemo has missing dependencies: 'isActive', 'limit', and 'mintCount'. Either include them or remove the dependency array.",["130"],"React Hook useMemo has a complex expression in the dependency array. Extract it to a separate variable so it can be statically checked.","UnaryExpression",{"desc":"131","fix":"132"},{"desc":"133","fix":"134"},{"desc":"135","fix":"136"},{"desc":"137","fix":"138"},{"desc":"139","fix":"140"},{"desc":"141","fix":"142"},{"desc":"143","fix":"144"},{"desc":"145","fix":"146"},{"desc":"147","fix":"148"},"Update the dependencies array to be: [mintedItems, throwConfetti]",{"range":"149","text":"150"},"Update the dependencies array to be: []",{"range":"151","text":"152"},"Update the dependencies array to be: [candyMachineV3, guardLabel, guards.burn.nfts, guards.gate.nfts, guards.payment.nfts]",{"range":"153","text":"154"},"Update the dependencies array to be: [candyMachineOpts.allowLists, wallet.publicKey]",{"range":"155","text":"156"},"Update the dependencies array to be: [candyMachineId, mx]",{"range":"157","text":"158"},"Update the dependencies array to be: [connection, mx, wallet, wallet.publicKey]",{"range":"159","text":"160"},"Update the dependencies array to be: [wallet.publicKey, nftHoldings, proofMemo, candyMachine, mx]",{"range":"161","text":"162"},"Update the dependencies array to be: [guardsAndGroups, candyMachine, wallet.publicKey, tokenHoldings, balance]",{"range":"163","text":"164"},"Update the dependencies array to be: [loading, isSoldOut, isMinting, isEnded, isActive, mintCount, limit]",{"range":"165","text":"166"},[5118,5131],"[mintedItems, throwConfetti]",[5588,5598],"[]",[6814,6843],"[candyMachineV3, guardLabel, guards.burn.nfts, guards.gate.nfts, guards.payment.nfts]",[3271,3326],"[candyMachineOpts.allowLists, wallet.publicKey]",[3507,3523],"[candyMachineId, mx]",[10886,10908],"[connection, mx, wallet, wallet.publicKey]",[12131,12187],"[wallet.publicKey, nftHoldings, proofMemo, candyMachine, mx]",[13208,13249],"[guardsAndGroups, candyMachine, wallet.publicKey, tokenHoldings, balance]",[7035,7086],"[loading, isSoldOut, isMinting, isEnded, isActive, mintCount, limit]"]