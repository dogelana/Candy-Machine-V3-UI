[{"C:\\Users\\Yebba\\Desktop\\bonkcards\\cm\\ui\\6\\Candy-Machine-V3-UI\\pages\\index.tsx":"1","C:\\Users\\Yebba\\Desktop\\bonkcards\\cm\\ui\\6\\Candy-Machine-V3-UI\\pages\\_app.tsx":"2","C:\\Users\\Yebba\\Desktop\\bonkcards\\cm\\ui\\6\\Candy-Machine-V3-UI\\src\\borsh\\mintCounter.ts":"3","C:\\Users\\Yebba\\Desktop\\bonkcards\\cm\\ui\\6\\Candy-Machine-V3-UI\\src\\config.ts":"4","C:\\Users\\Yebba\\Desktop\\bonkcards\\cm\\ui\\6\\Candy-Machine-V3-UI\\src\\helpers\\index.ts":"5","C:\\Users\\Yebba\\Desktop\\bonkcards\\cm\\ui\\6\\Candy-Machine-V3-UI\\src\\helpers\\MerkleTree.ts":"6","C:\\Users\\Yebba\\Desktop\\bonkcards\\cm\\ui\\6\\Candy-Machine-V3-UI\\src\\Home.tsx":"7","C:\\Users\\Yebba\\Desktop\\bonkcards\\cm\\ui\\6\\Candy-Machine-V3-UI\\src\\hooks\\types.ts":"8","C:\\Users\\Yebba\\Desktop\\bonkcards\\cm\\ui\\6\\Candy-Machine-V3-UI\\src\\hooks\\useCandyMachineV3.tsx":"9","C:\\Users\\Yebba\\Desktop\\bonkcards\\cm\\ui\\6\\Candy-Machine-V3-UI\\src\\hooks\\utils.ts":"10","C:\\Users\\Yebba\\Desktop\\bonkcards\\cm\\ui\\6\\Candy-Machine-V3-UI\\src\\main.tsx":"11","C:\\Users\\Yebba\\Desktop\\bonkcards\\cm\\ui\\6\\Candy-Machine-V3-UI\\src\\MintButton.tsx":"12","C:\\Users\\Yebba\\Desktop\\bonkcards\\cm\\ui\\6\\Candy-Machine-V3-UI\\src\\MultiMintButton.tsx":"13","C:\\Users\\Yebba\\Desktop\\bonkcards\\cm\\ui\\6\\Candy-Machine-V3-UI\\src\\NftsModal.tsx":"14","C:\\Users\\Yebba\\Desktop\\bonkcards\\cm\\ui\\6\\Candy-Machine-V3-UI\\src\\styles.ts":"15","C:\\Users\\Yebba\\Desktop\\bonkcards\\cm\\ui\\6\\Candy-Machine-V3-UI\\src\\utils.ts":"16"},{"size":338,"mtime":1673211249386,"results":"17","hashOfConfig":"18"},{"size":229,"mtime":1673211249385,"results":"19","hashOfConfig":"18"},{"size":625,"mtime":1673211249395,"results":"20","hashOfConfig":"18"},{"size":620,"mtime":1673251773092,"results":"21","hashOfConfig":"18"},{"size":31,"mtime":1673211249396,"results":"22","hashOfConfig":"18"},{"size":3348,"mtime":1673211249396,"results":"23","hashOfConfig":"18"},{"size":13795,"mtime":1673245804206,"results":"24","hashOfConfig":"18"},{"size":2758,"mtime":1673211249396,"results":"25","hashOfConfig":"18"},{"size":13575,"mtime":1673211249396,"results":"26","hashOfConfig":"18"},{"size":15658,"mtime":1673217540698,"results":"27","hashOfConfig":"18"},{"size":2170,"mtime":1673211249397,"results":"28","hashOfConfig":"18"},{"size":3240,"mtime":1673211249394,"results":"29","hashOfConfig":"18"},{"size":9235,"mtime":1673217803541,"results":"30","hashOfConfig":"18"},{"size":4472,"mtime":1673220412197,"results":"31","hashOfConfig":"18"},{"size":14471,"mtime":1673241324680,"results":"32","hashOfConfig":"18"},{"size":139,"mtime":1673211249397,"results":"33","hashOfConfig":"18"},{"filePath":"34","messages":"35","suppressedMessages":"36","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},"1sebo80",{"filePath":"37","messages":"38","suppressedMessages":"39","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"40","messages":"41","suppressedMessages":"42","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"43","messages":"44","suppressedMessages":"45","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"46","messages":"47","suppressedMessages":"48","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"49","messages":"50","suppressedMessages":"51","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"52","messages":"53","suppressedMessages":"54","errorCount":0,"fatalErrorCount":0,"warningCount":6,"fixableErrorCount":0,"fixableWarningCount":0,"source":"55"},{"filePath":"56","messages":"57","suppressedMessages":"58","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"59","messages":"60","suppressedMessages":"61","errorCount":0,"fatalErrorCount":0,"warningCount":5,"fixableErrorCount":0,"fixableWarningCount":0,"source":"62"},{"filePath":"63","messages":"64","suppressedMessages":"65","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"66","messages":"67","suppressedMessages":"68","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"69","messages":"70","suppressedMessages":"71","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"72","messages":"73","suppressedMessages":"74","errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"75"},{"filePath":"76","messages":"77","suppressedMessages":"78","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"79","messages":"80","suppressedMessages":"81","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"82","messages":"83","suppressedMessages":"84","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},"C:\\Users\\Yebba\\Desktop\\bonkcards\\cm\\ui\\6\\Candy-Machine-V3-UI\\pages\\index.tsx",[],[],"C:\\Users\\Yebba\\Desktop\\bonkcards\\cm\\ui\\6\\Candy-Machine-V3-UI\\pages\\_app.tsx",[],[],"C:\\Users\\Yebba\\Desktop\\bonkcards\\cm\\ui\\6\\Candy-Machine-V3-UI\\src\\borsh\\mintCounter.ts",[],[],"C:\\Users\\Yebba\\Desktop\\bonkcards\\cm\\ui\\6\\Candy-Machine-V3-UI\\src\\config.ts",[],[],"C:\\Users\\Yebba\\Desktop\\bonkcards\\cm\\ui\\6\\Candy-Machine-V3-UI\\src\\helpers\\index.ts",[],[],"C:\\Users\\Yebba\\Desktop\\bonkcards\\cm\\ui\\6\\Candy-Machine-V3-UI\\src\\helpers\\MerkleTree.ts",[],[],"C:\\Users\\Yebba\\Desktop\\bonkcards\\cm\\ui\\6\\Candy-Machine-V3-UI\\src\\Home.tsx",["85","86","87","88","89","90"],[],"import { useCallback } from \"react\";\r\nimport { Paper, Snackbar } from \"@material-ui/core\";\r\nimport Alert from \"@material-ui/lab/Alert\";\r\nimport { DefaultCandyGuardRouteSettings, Nft } from \"@metaplex-foundation/js\";\r\nimport { useConnection, useWallet } from \"@solana/wallet-adapter-react\";\r\nimport { WalletMultiButton } from \"@solana/wallet-adapter-react-ui\";\r\nimport { LAMPORTS_PER_SOL, PublicKey } from \"@solana/web3.js\";\r\nimport confetti from \"canvas-confetti\";\r\nimport Link from \"next/link\";\r\nimport Countdown from \"react-countdown\";\r\n\r\nimport { useEffect, useMemo, useState } from \"react\";\r\nimport styled from \"styled-components\";\r\nimport { GatewayProvider } from \"@civic/solana-gateway-react\";\r\nimport { defaultGuardGroup, network } from \"./config\";\r\n\r\nimport { MultiMintButton } from \"./MultiMintButton\";\r\nimport {\r\n  Heading,\r\n  Hero,\r\n  MintCount,\r\n  NftWrapper,\r\n  NftWrapper2,\r\n  Root,\r\n  StyledContainer,\r\n} from \"./styles\";\r\nimport { AlertState } from \"./utils\";\r\nimport NftsModal from \"./NftsModal\";\r\nimport { WalletAdapterNetwork } from \"@solana/wallet-adapter-base\";\r\nimport useCandyMachineV3 from \"./hooks/useCandyMachineV3\";\r\nimport {\r\n  CustomCandyGuardMintSettings,\r\n  NftPaymentMintSettings,\r\n  ParsedPricesForUI,\r\n} from \"./hooks/types\";\r\nimport { guardToLimitUtil } from \"./hooks/utils\";\r\n\r\nconst Header = styled.div`\r\n  display: flex;\r\n  justify-content: flex-end;\r\n  align-items: center;\r\n`;\r\nconst WalletContainer = styled.div`\r\n  display: flex;\r\n  flex-direction: row;\r\n  flex-wrap: wrap;\r\n  justify-content: right;\r\n  margin: 30px;\r\n  z-index: 999;\r\n  position: relative;\r\n\r\n  .wallet-adapter-dropdown-list {\r\n    background: #ffffff;\r\n  }\r\n  .wallet-adapter-dropdown-list-item {\r\n    background: #000000;\r\n  }\r\n  .wallet-adapter-dropdown-list {\r\n    grid-row-gap: 5px;\r\n  }\r\n`;\r\n\r\nconst WalletAmount = styled.div`\r\n  color: black;\r\n  width: auto;\r\n  padding: 5px 5px 5px 16px;\r\n  min-width: 48px;\r\n  min-height: auto;\r\n  border-radius: 5px;\r\n  background-color: #85b1e2;\r\n  box-shadow: 0px 3px 5px -1px rgb(0 0 0 / 20%),\r\n    0px 6px 10px 0px rgb(0 0 0 / 14%), 0px 1px 18px 0px rgb(0 0 0 / 12%);\r\n  box-sizing: border-box;\r\n  transition: background-color 250ms cubic-bezier(0.4, 0, 0.2, 1) 0ms,\r\n    box-shadow 250ms cubic-bezier(0.4, 0, 0.2, 1) 0ms,\r\n    border 250ms cubic-bezier(0.4, 0, 0.2, 1) 0ms;\r\n  font-weight: 500;\r\n  line-height: 1.75;\r\n  text-transform: uppercase;\r\n  border: 0;\r\n  margin: 0;\r\n  display: inline-flex;\r\n  outline: 0;\r\n  position: relative;\r\n  align-items: center;\r\n  user-select: none;\r\n  vertical-align: middle;\r\n  justify-content: flex-start;\r\n  gap: 10px;\r\n`;\r\n\r\nconst Wallet = styled.ul`\r\n  flex: 0 0 auto;\r\n  margin: 0;\r\n  padding: 0;\r\n`;\r\n\r\nconst ConnectButton = styled(WalletMultiButton)`\r\n  border-radius: 5px !important;\r\n  padding: 6px 16px;\r\n  background-color: #fff;\r\n  color: #000;\r\n  margin: 0 auto;\r\n`;\r\n\r\nconst Card = styled(Paper)`\r\n  display: inline-block;\r\n  background-color: var(--countdown-background-color) !important;\r\n  margin: 5px;\r\n  min-width: 40px;\r\n  padding: 24px;\r\n  h1 {\r\n    margin: 0px;\r\n  }\r\n`;\r\n\r\nexport interface HomeProps {\r\n  candyMachineId: PublicKey;\r\n}\r\nconst candyMachinOps = {\r\n  allowLists: [\r\n    {\r\n      list: require(\"../cmv3-demo-initialization/allowlist.json\"),\r\n      groupLabel: \"waoed\",\r\n    },\r\n  ],\r\n};\r\nconst Home = (props: HomeProps) => {\r\n  const { connection } = useConnection();\r\n  const wallet = useWallet();\r\n  const candyMachineV3 = useCandyMachineV3(\r\n    props.candyMachineId,\r\n    candyMachinOps\r\n  );\r\n\r\n  const [balance, setBalance] = useState<number>();\r\n  const [mintedItems, setMintedItems] = useState<Nft[]>();\r\n\r\n  const [alertState, setAlertState] = useState<AlertState>({\r\n    open: false,\r\n    message: \"\",\r\n    severity: undefined,\r\n  });\r\n\r\n  const { guardLabel, guards, guardStates, prices } = useMemo(() => {\r\n    const guardLabel = defaultGuardGroup;\r\n    return {\r\n      guardLabel,\r\n      guards:\r\n        candyMachineV3.guards[guardLabel] ||\r\n        candyMachineV3.guards.default ||\r\n        {},\r\n      guardStates: candyMachineV3.guardStates[guardLabel] ||\r\n        candyMachineV3.guardStates.default || {\r\n          isStarted: true,\r\n          isEnded: false,\r\n          isLimitReached: false,\r\n          canPayFor: 10,\r\n          messages: [],\r\n          isWalletWhitelisted: true,\r\n          hasGatekeeper: false,\r\n        },\r\n      prices: candyMachineV3.prices[guardLabel] ||\r\n        candyMachineV3.prices.default || {\r\n          payment: [],\r\n          burn: [],\r\n          gate: [],\r\n        },\r\n    };\r\n  }, [\r\n    candyMachineV3.guards,\r\n    candyMachineV3.guardStates,\r\n    candyMachineV3.prices,\r\n  ]);\r\n  useEffect(() => {\r\n    console.log({ guardLabel, guards, guardStates, prices });\r\n  }, [guardLabel, guards, guardStates, prices]);\r\n  useEffect(() => {\r\n    (async () => {\r\n      if (wallet?.publicKey) {\r\n        const balance = await connection.getBalance(wallet.publicKey);\r\n        setBalance(balance / LAMPORTS_PER_SOL);\r\n      }\r\n    })();\r\n  }, [wallet, connection]);\r\n\r\n  useEffect(() => {\r\n    if (mintedItems?.length === 0) throwConfetti();\r\n  }, [mintedItems]);\r\n\r\n  const openOnSolscan = useCallback((mint) => {\r\n    window.open(\r\n      `https://solscan.io/address/${mint}${\r\n        [WalletAdapterNetwork.Devnet, WalletAdapterNetwork.Testnet].includes(\r\n          network\r\n        )\r\n          ? `?cluster=${network}`\r\n          : \"\"\r\n      }`\r\n    );\r\n  }, []);\r\n\r\n  const throwConfetti = useCallback(() => {\r\n    confetti({\r\n      particleCount: 400,\r\n      spread: 70,\r\n      origin: { y: 0.6 },\r\n    });\r\n  }, [confetti]);\r\n\r\n  const startMint = useCallback(\r\n    async (quantityString: number = 1) => {\r\n      const nftGuards: NftPaymentMintSettings[] = Array(quantityString)\r\n        .fill(undefined)\r\n        .map((_, i) => {\r\n          return {\r\n            burn: guards.burn?.nfts?.length\r\n              ? {\r\n                  mint: guards.burn.nfts[i]?.mintAddress,\r\n                }\r\n              : undefined,\r\n            payment: guards.payment?.nfts?.length\r\n              ? {\r\n                  mint: guards.payment.nfts[i]?.mintAddress,\r\n                }\r\n              : undefined,\r\n            gate: guards.gate?.nfts?.length\r\n              ? {\r\n                  mint: guards.gate.nfts[i]?.mintAddress,\r\n                }\r\n              : undefined,\r\n          };\r\n        });\r\n\r\n      console.log({ nftGuards });\r\n      // debugger;\r\n      candyMachineV3\r\n        .mint(quantityString, {\r\n          groupLabel: guardLabel,\r\n          nftGuards,\r\n        })\r\n        .then((items) => {\r\n          setMintedItems(items as any);\r\n        })\r\n        .catch((e) =>\r\n          setAlertState({\r\n            open: true,\r\n            message: e.message,\r\n            severity: \"error\",\r\n          })\r\n        );\r\n    },\r\n    [candyMachineV3.mint, guards]\r\n  );\r\n\r\n  useEffect(() => {\r\n    console.log({ candyMachine: candyMachineV3.candyMachine });\r\n  }, [candyMachineV3.candyMachine]);\r\n\r\n  const MintButton = ({\r\n    gatekeeperNetwork,\r\n  }: {\r\n    gatekeeperNetwork?: PublicKey;\r\n  }) => (\r\n    <MultiMintButton\r\n      candyMachine={candyMachineV3.candyMachine}\r\n      gatekeeperNetwork={gatekeeperNetwork}\r\n      isMinting={candyMachineV3.status.minting}\r\n      setIsMinting={() => {}}\r\n      isActive={!!candyMachineV3.items.remaining}\r\n      isEnded={guardStates.isEnded}\r\n      isSoldOut={!candyMachineV3.items.remaining}\r\n      guardStates={guardStates}\r\n      onMint={startMint}\r\n      prices={prices}\r\n    />\r\n  );\r\n\r\n  return (\r\n    <main>\r\n      <>\r\n        <Header>\r\n          {/* <Link href='https://www.dogelana.com/bonkcards'>\r\n            <img\r\n              style={{\r\n                maxWidth: '200px',\r\n                marginLeft: 30,\r\n                marginTop: 10,\r\n              }}\r\n              src='/logo.png'\r\n              alt='logo'\r\n            />\r\n          </Link> */}\r\n          <WalletContainer>\r\n            <Wallet>\r\n              {wallet ? (\r\n                <WalletAmount>\r\n                  {(balance || 0).toLocaleString()} SOL\r\n                  <ConnectButton />\r\n                </WalletAmount>\r\n              ) : (\r\n                <ConnectButton>Connect Wallet</ConnectButton>\r\n              )}\r\n            </Wallet>\r\n          </WalletContainer>\r\n        </Header>\r\n        <Root>\r\n          <div className=\"cloud-content\">\r\n            {[...Array(7)].map((cloud, index) => (\r\n              <div key={index} className={`cloud-${index + 1} cloud-block`}>\r\n                <div className=\"cloud\"></div>\r\n              </div>\r\n            ))}\r\n          </div>\r\n          <StyledContainer>\r\n            {/* <MintNavigation /> */}\r\n\r\n            <Hero>\r\n              <Heading>\r\n                <Link href=\"/\">\r\n                  <img\r\n                    style={{\r\n                      maxWidth: \"350px\",\r\n                    }}\r\n                    src=\"/logo.png\"\r\n                    alt=\"logo\"\r\n                  />\r\n                </Link>\r\n              </Heading>\r\n\r\n              <p>\r\n              There are 2,222 unique BonkCards floating around the Solana blockchain. Special perks from the Dogelana community await the holders!\r\n              </p>\r\n\r\n              {guardStates.isStarted && (\r\n                <MintCount>\r\n                  Total Minted: {candyMachineV3.items.redeemed}/\r\n                  {candyMachineV3.items.available}{\" \"}\r\n                  {(guards?.mintLimit?.mintCounter?.count ||\r\n                    guards?.mintLimit?.settings?.limit) && (\r\n                    <>\r\n                      ({guards?.mintLimit?.mintCounter?.count || \"0\"}\r\n                      {guards?.mintLimit?.settings?.limit && (\r\n                        <>/{guards?.mintLimit?.settings?.limit} </>\r\n                      )}\r\n                      by you)\r\n                    </>\r\n                  )}\r\n                </MintCount>\r\n              )}\r\n\r\n              {!guardStates.isStarted ? (\r\n                <Countdown\r\n                  date={guards.startTime}\r\n                  renderer={renderGoLiveDateCounter}\r\n                  onComplete={() => {\r\n                    candyMachineV3.refresh();\r\n                  }}\r\n                />\r\n              ) : !wallet?.publicKey ? (\r\n                <ConnectButton>Connect Wallet</ConnectButton>\r\n              // ) : !guardStates.canPayFor ? (\r\n              //   <h1>You cannot pay for the mint</h1>\r\n              ) : !guardStates.isWalletWhitelisted ? (\r\n                <h1>Mint is private.</h1>\r\n              ) : (\r\n                <>\r\n                  <>\r\n                    {!!candyMachineV3.items.remaining &&\r\n                    guardStates.hasGatekeeper &&\r\n                    wallet.publicKey &&\r\n                    wallet.signTransaction ? (\r\n                      <GatewayProvider\r\n                        wallet={{\r\n                          publicKey: wallet.publicKey,\r\n                          //@ts-ignore\r\n                          signTransaction: wallet.signTransaction,\r\n                        }}\r\n                        gatekeeperNetwork={guards.gatekeeperNetwork}\r\n                        connection={connection}\r\n                        cluster={\r\n                          process.env.NEXT_PUBLIC_SOLANA_NETWORK || \"devnet\"\r\n                        }\r\n                        options={{ autoShowModal: false }}\r\n                      >\r\n                        <MintButton\r\n                          gatekeeperNetwork={guards.gatekeeperNetwork}\r\n                        />\r\n                      </GatewayProvider>\r\n                    ) : (\r\n                      <MintButton />\r\n                    )}\r\n                  </>\r\n                </>\r\n              )}\r\n            </Hero>\r\n            <NftsModal\r\n              openOnSolscan={openOnSolscan}\r\n              mintedItems={mintedItems || []}\r\n              setMintedItems={setMintedItems}\r\n            />\r\n          </StyledContainer>\r\n          <NftWrapper>\r\n            <div className=\"marquee-wrapper\">\r\n              <div className=\"marquee\">\r\n                {[...Array(21)].map((item, index) => (\r\n                  <img\r\n                    key={index}\r\n                    src={`/nfts/${index + 1}.png`}\r\n                    height=\"200px\"\r\n                    width=\"200px\"\r\n                    alt=\"\"\r\n                  />\r\n                ))}\r\n              </div>\r\n            </div>\r\n          </NftWrapper>\r\n          <NftWrapper2>\r\n            <div className=\"marquee-wrapper second\">\r\n              <div className=\"marquee\">\r\n                {[...Array(21)].map((item, index) => (\r\n                  <img\r\n                    key={index}\r\n                    src={`/nfts/${index + 1}.png`}\r\n                    height=\"200px\"\r\n                    width=\"200px\"\r\n                    alt=\"\"\r\n                  />\r\n                ))}\r\n              </div>\r\n            </div>\r\n          </NftWrapper2>\r\n        </Root>\r\n      </>\r\n      <Snackbar\r\n        open={alertState.open}\r\n        autoHideDuration={6000}\r\n        onClose={() => setAlertState({ ...alertState, open: false })}\r\n      >\r\n        <Alert\r\n          onClose={() => setAlertState({ ...alertState, open: false })}\r\n          severity={alertState.severity}\r\n        >\r\n          {alertState.message}\r\n        </Alert>\r\n      </Snackbar>\r\n    </main>\r\n  );\r\n};\r\n\r\nexport default Home;\r\n\r\nconst renderGoLiveDateCounter = ({ days, hours, minutes, seconds }: any) => {\r\n  return (\r\n    <div>\r\n      <Card elevation={1}>\r\n        <h1>{days}</h1>Days\r\n      </Card>\r\n      <Card elevation={1}>\r\n        <h1>{hours}</h1>\r\n        Hours\r\n      </Card>\r\n      <Card elevation={1}>\r\n        <h1>{minutes}</h1>Mins\r\n      </Card>\r\n      <Card elevation={1}>\r\n        <h1>{seconds}</h1>Secs\r\n      </Card>\r\n    </div>\r\n  );\r\n};\r\n","C:\\Users\\Yebba\\Desktop\\bonkcards\\cm\\ui\\6\\Candy-Machine-V3-UI\\src\\hooks\\types.ts",[],[],"C:\\Users\\Yebba\\Desktop\\bonkcards\\cm\\ui\\6\\Candy-Machine-V3-UI\\src\\hooks\\useCandyMachineV3.tsx",["91","92","93","94","95"],[],"import {\r\n  callCandyGuardRouteBuilder,\r\n  CandyMachine,\r\n  getMerkleProof,\r\n  getMerkleTree,\r\n  IdentitySigner,\r\n  Metadata,\r\n  Metaplex,\r\n  mintFromCandyMachineBuilder,\r\n  Nft,\r\n  NftWithToken,\r\n  PublicKey,\r\n  Sft,\r\n  SftWithToken,\r\n  TransactionBuilder,\r\n  walletAdapterIdentity,\r\n} from \"@metaplex-foundation/js\";\r\nimport { useConnection, useWallet } from \"@solana/wallet-adapter-react\";\r\n\r\nimport { TOKEN_PROGRAM_ID } from \"@solana/spl-token\";\r\nimport React from \"react\";\r\nimport { MerkleTree } from \"merkletreejs\";\r\nimport {\r\n  AllowLists,\r\n  CustomCandyGuardMintSettings,\r\n  GuardGroup,\r\n  GuardGroupStates,\r\n  NftPaymentMintSettings,\r\n  ParsedPricesForUI,\r\n  Token,\r\n} from \"./types\";\r\nimport {\r\n  fetchMintLimit,\r\n  guardToPaymentUtil,\r\n  mergeGuards,\r\n  parseGuardGroup,\r\n  parseGuardStates,\r\n} from \"./utils\";\r\n\r\nexport default function useCandyMachineV3(\r\n  candyMachineId: PublicKey | string,\r\n  candyMachineOpts: {\r\n    allowLists?: AllowLists;\r\n  } = {}\r\n) {\r\n  const { connection } = useConnection();\r\n  const wallet = useWallet();\r\n  const [guardsAndGroups, setGuardsAndGroups] = React.useState<{\r\n    default?: GuardGroup;\r\n    [k: string]: GuardGroup;\r\n  }>({});\r\n\r\n  const [status, setStatus] = React.useState({\r\n    candyMachine: false,\r\n    guardGroups: false,\r\n    minting: false,\r\n    initialFetchGuardGroupsDone: false,\r\n  });\r\n\r\n  const [balance, setBalance] = React.useState(0);\r\n  const [allTokens, setAllTokens] = React.useState<Token[]>([]);\r\n  const [nftHoldings, setNftHoldings] = React.useState<Metadata[]>([]);\r\n\r\n  const tokenHoldings = React.useMemo<Token[]>(() => {\r\n    if (!nftHoldings?.length || !allTokens?.length) return [];\r\n    return allTokens.filter(\r\n      (x) => !nftHoldings.find((y) => x.mint.equals(y.address))\r\n    );\r\n  }, [nftHoldings, allTokens]);\r\n\r\n  const [candyMachine, setCandyMachine] = React.useState<CandyMachine>(null);\r\n  const [items, setItems] = React.useState({\r\n    available: 0,\r\n    remaining: 0,\r\n    redeemed: 0,\r\n  });\r\n\r\n  const mx = React.useMemo(\r\n    () => connection && Metaplex.make(connection),\r\n    [connection]\r\n  );\r\n\r\n  const proofMemo = React.useMemo(() => {\r\n    if (!candyMachineOpts.allowLists?.length) {\r\n      return {\r\n        merkles: {},\r\n        verifyProof() {\r\n          return true;\r\n        },\r\n      };\r\n    }\r\n    if (!wallet.publicKey) {\r\n      return {\r\n        merkles: {},\r\n        verifyProof() {\r\n          return false;\r\n        },\r\n      };\r\n    }\r\n    const merkles: { [k: string]: { tree: MerkleTree; proof: Uint8Array[] } } =\r\n      candyMachineOpts.allowLists.reduce(\r\n        (prev, { groupLabel, list }) =>\r\n          Object.assign(prev, {\r\n            [groupLabel]: {\r\n              tree: getMerkleTree(list),\r\n              proof: getMerkleProof(list, wallet.publicKey.toString()),\r\n            },\r\n          }),\r\n        {}\r\n      );\r\n    const verifyProof = (\r\n      merkleRoot: Uint8Array | string,\r\n      label = \"default\"\r\n    ) => {\r\n      let merkle = merkles[label];\r\n      if (!merkle) return;\r\n      const verifiedProof = !!merkle.proof.length;\r\n      const compareRoot = merkle.tree.getRoot().equals(Buffer.from(merkleRoot));\r\n      return verifiedProof && compareRoot;\r\n    };\r\n    return {\r\n      merkles,\r\n      verifyProof,\r\n    };\r\n  }, [wallet.publicKey, candyMachineOpts.allowLists?.length]);\r\n\r\n  const fetchCandyMachine = React.useCallback(async () => {\r\n    return await mx.candyMachines().findByAddress({\r\n      address: new PublicKey(candyMachineId),\r\n    });\r\n  }, [candyMachineId]);\r\n\r\n  const refresh = React.useCallback(async () => {\r\n    if (!wallet.publicKey) throw new Error(\"Wallet not loaded yet!\");\r\n\r\n    setStatus((x) => ({ ...x, candyMachine: true }));\r\n    await fetchCandyMachine()\r\n      .then((cndy) => {\r\n        setCandyMachine(cndy);\r\n        setItems({\r\n          available: cndy.itemsAvailable.toNumber(),\r\n          remaining: cndy.itemsRemaining.toNumber(),\r\n          redeemed: cndy.itemsMinted.toNumber(),\r\n        });\r\n\r\n        return cndy;\r\n      })\r\n      .catch((e) => console.error(\"Error while fetching candy machine\", e))\r\n      .finally(() => setStatus((x) => ({ ...x, candyMachine: false })));\r\n  }, [fetchCandyMachine, wallet.publicKey]);\r\n\r\n  const mint = React.useCallback(\r\n    async (\r\n      quantityString: number = 1,\r\n      opts: {\r\n        groupLabel?: string;\r\n        nftGuards?: NftPaymentMintSettings[];\r\n      } = {}\r\n    ) => {\r\n      if (!guardsAndGroups[opts.groupLabel || \"default\"])\r\n        throw new Error(\"Unknown guard group label\");\r\n\r\n      const allowList = opts.groupLabel &&\r\n        proofMemo.merkles[opts.groupLabel] && {\r\n          proof: proofMemo.merkles[opts.groupLabel].proof,\r\n        };\r\n\r\n      let nfts: (Sft | SftWithToken | Nft | NftWithToken)[] = [];\r\n      try {\r\n        if (!candyMachine) throw new Error(\"Candy Machine not loaded yet!\");\r\n\r\n        setStatus((x) => ({\r\n          ...x,\r\n          minting: true,\r\n        }));\r\n\r\n        const transactionBuilders: TransactionBuilder[] = [];\r\n        if (allowList) {\r\n          if (!proofMemo.merkles[opts.groupLabel || \"default\"].proof.length)\r\n            throw new Error(\"User is not in allowed list\");\r\n\r\n          transactionBuilders.push(\r\n            callCandyGuardRouteBuilder(mx, {\r\n              candyMachine,\r\n              guard: \"allowList\",\r\n              group: opts.groupLabel,\r\n              settings: {\r\n                path: \"proof\",\r\n                merkleProof:\r\n                  proofMemo.merkles[opts.groupLabel || \"default\"].proof,\r\n              },\r\n            })\r\n          );\r\n        }\r\n        for (let index = 0; index < quantityString; index++) {\r\n          transactionBuilders.push(\r\n            await mintFromCandyMachineBuilder(mx, {\r\n              candyMachine,\r\n              collectionUpdateAuthority: candyMachine.authorityAddress, // mx.candyMachines().pdas().authority({candyMachine: candyMachine.address})\r\n              group: opts.groupLabel,\r\n              guards: {\r\n                nftBurn: opts.nftGuards && opts.nftGuards[index]?.burn,\r\n                nftPayment: opts.nftGuards && opts.nftGuards[index]?.payment,\r\n                nftGate: opts.nftGuards && opts.nftGuards[index]?.gate,\r\n                allowList,\r\n              },\r\n            })\r\n          );\r\n        }\r\n        const blockhash = await mx.rpc().getLatestBlockhash();\r\n\r\n        const transactions = transactionBuilders.map((t) =>\r\n          t.toTransaction(blockhash)\r\n        );\r\n        const signers: { [k: string]: IdentitySigner } = {};\r\n        transactions.forEach((tx, i) => {\r\n          tx.feePayer = wallet.publicKey;\r\n          tx.recentBlockhash = blockhash.blockhash;\r\n          transactionBuilders[i].getSigners().forEach((s) => {\r\n            if (\"signAllTransactions\" in s) signers[s.publicKey.toString()] = s;\r\n            else if (\"secretKey\" in s) tx.partialSign(s);\r\n            // @ts-ignore\r\n            else if (\"_signer\" in s) tx.partialSign(s._signer);\r\n          });\r\n        });\r\n        let signedTransactions = transactions;\r\n\r\n        for (let signer in signers) {\r\n          await signers[signer].signAllTransactions(transactions);\r\n        }\r\n        if (allowList) {\r\n          const allowListCallGuardRouteTx = signedTransactions.shift();\r\n          const allowListCallGuardRouteTxBuilder = transactionBuilders.shift();\r\n          await mx.rpc().sendAndConfirmTransaction(allowListCallGuardRouteTx, {\r\n            commitment: \"processed\",\r\n          });\r\n        }\r\n        const output = await Promise.all(\r\n          signedTransactions.map((tx, i) => {\r\n            return mx\r\n              .rpc()\r\n              .sendAndConfirmTransaction(tx, { commitment: \"finalized\" })\r\n              .then((tx) => ({\r\n                ...tx,\r\n                context: transactionBuilders[i].getContext() as any,\r\n              }));\r\n          })\r\n        );\r\n        nfts = await Promise.all(\r\n          output.map(({ context }) =>\r\n            mx\r\n              .nfts()\r\n              .findByMint({\r\n                mintAddress: context.mintSigner.publicKey,\r\n                tokenAddress: context.tokenAddress,\r\n              })\r\n              .catch((e) => null)\r\n          )\r\n        );\r\n        Object.values(guardsAndGroups).forEach((guards) => {\r\n          if (guards.mintLimit?.mintCounter)\r\n            guards.mintLimit.mintCounter.count += nfts.length;\r\n        });\r\n        // setItems((x) => ({\r\n        //   ...x,\r\n        //   remaining: x.remaining - nfts.length,\r\n        //   redeemed: x.redeemed + nfts.length,\r\n        // }));\r\n      } catch (error: any) {\r\n        let message = error.msg || \"Minting failed! Please try again!\";\r\n        if (!error.msg) {\r\n          if (!error.message) {\r\n            message = \"Transaction Timeout! Please try again.\";\r\n          } else if (error.message.indexOf(\"0x138\")) {\r\n          } else if (error.message.indexOf(\"0x137\")) {\r\n            message = `SOLD OUT!`;\r\n          } else if (error.message.indexOf(\"0x135\")) {\r\n            message = `Insufficient funds to mint. Please fund your wallet.`;\r\n          }\r\n        } else {\r\n          if (error.code === 311) {\r\n            message = `SOLD OUT!`;\r\n          } else if (error.code === 312) {\r\n            message = `Minting period hasn't started yet.`;\r\n          }\r\n        }\r\n        console.error(error);\r\n        throw new Error(message);\r\n      } finally {\r\n        setStatus((x) => ({ ...x, minting: false }));\r\n        refresh();\r\n        return nfts.filter((a) => a);\r\n      }\r\n    },\r\n    [candyMachine, guardsAndGroups, mx, wallet?.publicKey, proofMemo, refresh]\r\n  );\r\n\r\n  React.useEffect(() => {\r\n    if (!mx || !wallet.publicKey) return;\r\n    console.log(\"useEffact([mx, wallet.publicKey])\");\r\n    mx.use(walletAdapterIdentity(wallet));\r\n\r\n    mx.rpc()\r\n      .getBalance(wallet.publicKey)\r\n      .then((x) => x.basisPoints.toNumber())\r\n      .then(setBalance)\r\n      .catch((e) => console.error(\"Error to fetch wallet balance\", e));\r\n\r\n    mx.nfts()\r\n      .findAllByOwner({\r\n        owner: wallet.publicKey,\r\n      })\r\n      .then((x) =>\r\n        setNftHoldings(x.filter((a) => a.model == \"metadata\") as any)\r\n      )\r\n      .catch((e) => console.error(\"Failed to fetch wallet nft holdings\", e));\r\n\r\n    (async (walletAddress: PublicKey): Promise<Token[]> => {\r\n      const tokenAccounts = (\r\n        await connection.getParsedTokenAccountsByOwner(walletAddress, {\r\n          programId: TOKEN_PROGRAM_ID,\r\n        })\r\n      ).value.filter(\r\n        (x) => parseInt(x.account.data.parsed.info.tokenAmount.amount) > 1\r\n      );\r\n\r\n      return tokenAccounts.map((x) => ({\r\n        mint: new PublicKey(x.account.data.parsed.info.mint),\r\n        balance: parseInt(x.account.data.parsed.info.tokenAmount.amount),\r\n        decimals: x.account.data.parsed.info.tokenAmount.decimals,\r\n      }));\r\n    })(wallet.publicKey).then(setAllTokens);\r\n  }, [mx, wallet.publicKey]);\r\n\r\n  React.useEffect(() => {\r\n    refresh().catch((e) =>\r\n      console.error(\"Error while fetching candy machine\", e)\r\n    );\r\n  }, [refresh]);\r\n\r\n  React.useEffect(() => {\r\n    const walletAddress = wallet.publicKey;\r\n    if (!walletAddress || !candyMachine) return;\r\n    console.log(\r\n      \"useEffact([mx, wallet, nftHoldings, proofMemo, candyMachine])\"\r\n    );\r\n\r\n    (async () => {\r\n      const guards = {\r\n        default: await parseGuardGroup(\r\n          {\r\n            guards: candyMachine.candyGuard.guards,\r\n            candyMachine,\r\n            nftHoldings,\r\n            verifyProof: proofMemo.verifyProof,\r\n            walletAddress,\r\n          },\r\n          mx\r\n        ),\r\n      };\r\n      await Promise.all(\r\n        candyMachine.candyGuard.groups.map(async (x) => {\r\n          guards[x.label] = await parseGuardGroup(\r\n            {\r\n              guards: mergeGuards([candyMachine.candyGuard.guards, x.guards]),\r\n              label: x.label,\r\n              candyMachine,\r\n              nftHoldings,\r\n              verifyProof: proofMemo.verifyProof,\r\n              walletAddress,\r\n            },\r\n            mx\r\n          );\r\n        })\r\n      );\r\n      setGuardsAndGroups(guards);\r\n    })();\r\n  }, [wallet.publicKey, nftHoldings, proofMemo, candyMachine]);\r\n\r\n  const prices = React.useMemo((): {\r\n    default?: ParsedPricesForUI;\r\n    [k: string]: ParsedPricesForUI;\r\n  } => {\r\n    // if (!status.initialFetchGuardGroupsDone) return {};\r\n    // const prices = {\r\n    // };\r\n    return Object.entries(guardsAndGroups).reduce(\r\n      (groupPayments, [label, guards]) => {\r\n        // console.log(label, guards);\r\n        return Object.assign(groupPayments, {\r\n          [label]: guardToPaymentUtil(guards),\r\n        });\r\n      },\r\n      {}\r\n    );\r\n  }, [guardsAndGroups]);\r\n\r\n  const guardStates = React.useMemo((): {\r\n    default?: GuardGroupStates;\r\n    [k: string]: GuardGroupStates;\r\n  } => {\r\n    return Object.entries(guardsAndGroups).reduce(\r\n      (groupPayments, [label, guards]) =>\r\n        Object.assign(groupPayments, {\r\n          [label]: parseGuardStates({\r\n            guards: guards,\r\n            candyMachine,\r\n            walletAddress: wallet.publicKey,\r\n            tokenHoldings,\r\n            balance,\r\n          }),\r\n        }),\r\n      {}\r\n    );\r\n  }, [guardsAndGroups, tokenHoldings, balance]);\r\n\r\n  React.useEffect(() => {\r\n    console.log({ guardsAndGroups, guardStates, prices });\r\n  }, [guardsAndGroups, guardStates, prices]);\r\n\r\n  return {\r\n    candyMachine,\r\n    guards: guardsAndGroups,\r\n    guardStates,\r\n    status,\r\n    items,\r\n    merkles: proofMemo.merkles,\r\n    prices,\r\n    mint,\r\n    refresh,\r\n  };\r\n}\r\n","C:\\Users\\Yebba\\Desktop\\bonkcards\\cm\\ui\\6\\Candy-Machine-V3-UI\\src\\hooks\\utils.ts",[],[],"C:\\Users\\Yebba\\Desktop\\bonkcards\\cm\\ui\\6\\Candy-Machine-V3-UI\\src\\main.tsx",[],[],"C:\\Users\\Yebba\\Desktop\\bonkcards\\cm\\ui\\6\\Candy-Machine-V3-UI\\src\\MintButton.tsx",[],[],"C:\\Users\\Yebba\\Desktop\\bonkcards\\cm\\ui\\6\\Candy-Machine-V3-UI\\src\\MultiMintButton.tsx",["96","97"],[],"import { CircularProgress } from \"@material-ui/core\";\r\nimport Button from \"@material-ui/core/Button\";\r\nimport { CandyMachine } from \"@metaplex-foundation/js\";\r\nimport { useEffect, useMemo, useRef, useState } from \"react\";\r\nimport styled from \"styled-components\";\r\nimport { useConnection, useWallet } from \"@solana/wallet-adapter-react\";\r\nimport { PublicKey } from \"@solana/web3.js\";\r\nimport { GatewayStatus, useGateway } from \"@civic/solana-gateway-react\";\r\nimport { GuardGroupStates, ParsedPricesForUI, PaymentRequired } from \"./hooks/types\";\r\n\r\nexport const CTAButton = styled(Button)`\r\n  display: inline-block !important;\r\n  margin: 10px auto !important;\r\n  background-color: #fff !important;\r\n  color: #000 !important;\r\n  min-width: 258px !important;\r\n  font-size: 1em !important;\r\n  font-family: \"Patrick Hand\", cursive;\r\n  font-weight: bold !important;\r\n`;\r\n\r\nexport const Minus = styled.button`\r\n  font-size: 2em;\r\n  padding: 25px 35px;\r\n  font-weight: bold;\r\n  line-height: 0.5px;\r\n  color: #000;\r\n  background: #fff;\r\n  box-shadow: 0px 3px 5px -1px rgb(0 0 0 / 20%),\r\n    0px 6px 10px 0px rgb(0 0 0 / 14%), 0px 1px 18px 0px rgb(0 0 0 / 12%);\r\n  border: 0;\r\n  border-radius: 5px;\r\n  box-sizing: border-box;\r\n  font-family: \"Patrick Hand\", cursive;\r\n  vertical-align: middle;\r\n  transition: all linear 0.3s;\r\n\r\n  :hover {\r\n    border: none;\r\n    outline: none !important;\r\n    background: #d09a69;\r\n  }\r\n  :not(disabled) {\r\n    cursor: pointer;\r\n  }\r\n\r\n  :not(disabled):hover {\r\n    outline: 1px solid var(--title-text-color);\r\n  }\r\n`;\r\n\r\nexport const Plus = styled(Minus)`\r\n  margin-left: 0;\r\n`;\r\n\r\nexport const NumericField = styled.input`\r\n  font-size: 2em !important;\r\n  padding: 0;\r\n  vertical-align: middle;\r\n  background-color: var(--main-text-color);\r\n  box-shadow: 0px 3px 5px -1px rgb(0 0 0 / 20%),\r\n    0px 6px 10px 0px rgb(0 0 0 / 14%), 0px 1px 18px 0px rgb(0 0 0 / 12%);\r\n  box-sizing: border-box;\r\n  font-family: \"Patrick Hand\", cursive;\r\n  font-weight: 500;\r\n  line-height: 1px;\r\n  border: none;\r\n  text-align: center;\r\n  border-radius: 5px;\r\n  transition: all 0.4s ease;\r\n  -moz-appearance: textfield;\r\n  -webkit-appearance: none;\r\n  margin: 0 10px;\r\n\r\n  :hover,\r\n  :focus {\r\n    box-shadow: 0px 3px 5px -1px rgb(0 0 0 / 40%),\r\n      0px 6px 10px 0px rgb(0 0 0 / 34%), 0px 1px 18px 0px rgb(0 0 0 / 32%);\r\n  }\r\n\r\n  ::-webkit-outer-spin-button,\r\n  ::-webkit-inner-spin-button {\r\n    -webkit-appearance: none;\r\n  }\r\n`;\r\nfunction usePrevious<T>(value: T): T | undefined {\r\n  const ref = useRef<T>();\r\n  useEffect(() => {\r\n    ref.current = value;\r\n  }, [value]);\r\n  return ref.current;\r\n}\r\nconst deepClone = (items: PaymentRequired[]) =>\r\n  items.map((item) => ({ ...item }));\r\nexport const MultiMintButton = ({\r\n  onMint,\r\n  candyMachine,\r\n  isMinting,\r\n  setIsMinting,\r\n  isEnded,\r\n  isActive,\r\n  isSoldOut,\r\n  prices,\r\n  guardStates,\r\n  gatekeeperNetwork,\r\n}: {\r\n  onMint: (quantityString: number) => Promise<void>;\r\n  candyMachine: CandyMachine | undefined;\r\n  isMinting: boolean;\r\n  setIsMinting: (val: boolean) => void;\r\n  isEnded: boolean;\r\n  isActive: boolean;\r\n  isSoldOut: boolean;\r\n  prices: ParsedPricesForUI;\r\n  guardStates: GuardGroupStates;\r\n  gatekeeperNetwork?: PublicKey;\r\n}) => {\r\n  const [loading, setLoading] = useState(false);\r\n\r\n  const [mintCount, setMintCount] = useState(1);\r\n  const { requestGatewayToken, gatewayStatus } = useGateway();\r\n  const [waitForActiveToken, setWaitForActiveToken] = useState(false);\r\n  const limit = useMemo(() => guardStates.canPayFor, [guardStates]);\r\n\r\n  const totalSolCost = useMemo(\r\n    () =>\r\n      prices\r\n        ? mintCount *\r\n          (prices.payment\r\n            .filter(({ kind }) => kind === \"sol\")\r\n            .reduce((a, { price }) => a + price, 0) +\r\n            0.012)\r\n        : 0.012,\r\n    [mintCount, prices]\r\n  );\r\n  const totalTokenCosts = useMemo((): PaymentRequired[] => {\r\n    if (!prices) return [];\r\n    const maxPriceHash: { [k: string]: number } = {};\r\n    const payment$burn$lenth = prices.payment.length + prices.burn.length;\r\n    let payments = deepClone(\r\n      prices.payment.concat(prices.burn).concat(prices.gate)\r\n    ).filter((price, index) => {\r\n      const cacheKey = price.mint?.toString();\r\n      if (![\"token\", \"nft\"].includes(price.kind)) return false;\r\n      const alreadyFound = !!maxPriceHash[cacheKey];\r\n      if (index < payment$burn$lenth) price.price *= mintCount;\r\n      price.price = maxPriceHash[cacheKey] = Math.max(\r\n        maxPriceHash[cacheKey] || 0,\r\n        price.price\r\n      );\r\n      return !alreadyFound;\r\n    });\r\n    return payments;\r\n  }, [mintCount, prices]);\r\n  const totalTokenCostsString = useMemo(() => {\r\n    return totalTokenCosts.reduce(\r\n      (text, price) => `${text} (Must hold at least 1,000,000 BONK!)`,\r\n      \"\"\r\n    );\r\n  }, [totalTokenCosts]);\r\n\r\n  const previousGatewayStatus = usePrevious(gatewayStatus);\r\n  useEffect(() => {\r\n    const fromStates = [\r\n      GatewayStatus.NOT_REQUESTED,\r\n      GatewayStatus.REFRESH_TOKEN_REQUIRED,\r\n    ];\r\n    const invalidToStates = [...fromStates, GatewayStatus.UNKNOWN];\r\n    if (\r\n      fromStates.find((state) => previousGatewayStatus === state) &&\r\n      !invalidToStates.find((state) => gatewayStatus === state)\r\n    ) {\r\n      setIsMinting(true);\r\n    }\r\n    // console.log(\"change: \", GatewayStatus[gatewayStatus]);\r\n  }, [previousGatewayStatus, gatewayStatus, setIsMinting]);\r\n\r\n  useEffect(() => {\r\n    if (waitForActiveToken && gatewayStatus === GatewayStatus.ACTIVE) {\r\n      console.log(\"Minting after token active\");\r\n      setWaitForActiveToken(false);\r\n      onMint(mintCount);\r\n    }\r\n  }, [waitForActiveToken, gatewayStatus, onMint, mintCount]);\r\n\r\n  function incrementValue() {\r\n    var numericField = document.querySelector(\".mint-qty\") as HTMLInputElement;\r\n    if (numericField) {\r\n      var value = parseInt(numericField.value);\r\n      if (!isNaN(value) && value < 10) {\r\n        value++;\r\n        numericField.value = \"\" + value;\r\n        updateAmounts(value);\r\n      }\r\n    }\r\n  }\r\n\r\n  function decrementValue() {\r\n    var numericField = document.querySelector(\".mint-qty\") as HTMLInputElement;\r\n    if (numericField) {\r\n      var value = parseInt(numericField.value);\r\n      if (!isNaN(value) && value > 1) {\r\n        value--;\r\n        numericField.value = \"\" + value;\r\n        updateAmounts(value);\r\n      }\r\n    }\r\n  }\r\n\r\n  function updateMintCount(target: any) {\r\n    var value = parseInt(target.value);\r\n    if (!isNaN(value)) {\r\n      if (value > 10) {\r\n        value = 10;\r\n        target.value = \"\" + value;\r\n      } else if (value < 1) {\r\n        value = 1;\r\n        target.value = \"\" + value;\r\n      }\r\n      updateAmounts(value);\r\n    }\r\n  }\r\n\r\n  function updateAmounts(qty: number) {\r\n    setMintCount(qty);\r\n    // setTotalCost(Math.round(qty * (price + 0.012) * 1000) / 1000); // 0.012 = approx of account creation fees\r\n  }\r\n  const disabled = useMemo(\r\n    () =>\r\n      loading ||\r\n      isSoldOut ||\r\n      isMinting ||\r\n      isEnded ||\r\n      !isActive ||\r\n      mintCount > limit,\r\n    [loading, isSoldOut, isMinting, isEnded, !isActive]\r\n  );\r\n  return (\r\n    <div>\r\n      <div>\r\n        <Minus\r\n          disabled={disabled || mintCount <= 1}\r\n          onClick={() => decrementValue()}\r\n        >\r\n          <span style={{ marginTop: \"-5px !important\" }}>-</span>\r\n        </Minus>\r\n        <NumericField\r\n          disabled={disabled}\r\n          type=\"number\"\r\n          className=\"mint-qty\"\r\n          step={1}\r\n          min={1}\r\n          max={Math.min(limit, 10)}\r\n          value={mintCount}\r\n          onChange={(e) => updateMintCount(e.target as any)}\r\n        />\r\n        <Plus\r\n          disabled={disabled || limit <= mintCount}\r\n          onClick={() => incrementValue()}\r\n        >\r\n          +\r\n        </Plus>\r\n\r\n        <br />\r\n        <CTAButton\r\n          disabled={disabled}\r\n          onClick={async () => {\r\n            console.log(\"isActive gatekeeperNetwork\", {\r\n              isActive,\r\n              gatekeeperNetwork,\r\n            });\r\n            if (isActive && gatekeeperNetwork) {\r\n              if (gatewayStatus === GatewayStatus.ACTIVE) {\r\n                await onMint(mintCount);\r\n              } else {\r\n                setWaitForActiveToken(true);\r\n                await requestGatewayToken();\r\n              }\r\n            } else {\r\n              await onMint(mintCount);\r\n            }\r\n          }}\r\n          variant=\"contained\"\r\n        >\r\n          {!candyMachine ? (\r\n            \"CONNECTING...\"\r\n          ) : isSoldOut ? (\r\n            \"SOLD OUT\"\r\n          ) : isActive ? guardStates.messages.length ? (guardStates.messages[0]) : (\r\n            mintCount > limit ? (\r\n              \"LIMIT REACHED\"\r\n            ) : isMinting || loading ? (\r\n              <CircularProgress />\r\n            ) : (\r\n              \"MINT\"\r\n            )\r\n          ) : isEnded ? (\r\n            \"ENDED\"\r\n          ) : (\r\n            \"UNAVAILABLE\"\r\n          )}\r\n        </CTAButton>\r\n      </div>\r\n      {!isSoldOut && isActive && (\r\n        <h3>\r\n          Total Cost: {totalSolCost} SOL\r\n          {totalTokenCostsString}\r\n        </h3>\r\n      )}\r\n        {guardStates.messages?.map((m, i) => (\r\n          <p key={i}>{m}</p>\r\n        ))}\r\n    </div>\r\n  );\r\n};\r\n","C:\\Users\\Yebba\\Desktop\\bonkcards\\cm\\ui\\6\\Candy-Machine-V3-UI\\src\\NftsModal.tsx",[],[],"C:\\Users\\Yebba\\Desktop\\bonkcards\\cm\\ui\\6\\Candy-Machine-V3-UI\\src\\styles.ts",[],[],"C:\\Users\\Yebba\\Desktop\\bonkcards\\cm\\ui\\6\\Candy-Machine-V3-UI\\src\\utils.ts",[],[],{"ruleId":"98","severity":1,"message":"99","line":189,"column":6,"nodeType":"100","endLine":189,"endColumn":19,"suggestions":"101"},{"ruleId":"98","severity":1,"message":"102","line":209,"column":6,"nodeType":"100","endLine":209,"endColumn":16,"suggestions":"103"},{"ruleId":"98","severity":1,"message":"104","line":253,"column":5,"nodeType":"100","endLine":253,"endColumn":34,"suggestions":"105"},{"ruleId":"106","severity":1,"message":"107","line":321,"column":19,"nodeType":"108","endLine":327,"endColumn":21},{"ruleId":"106","severity":1,"message":"107","line":407,"column":19,"nodeType":"108","endLine":413,"endColumn":21},{"ruleId":"106","severity":1,"message":"107","line":422,"column":19,"nodeType":"108","endLine":428,"endColumn":21},{"ruleId":"98","severity":1,"message":"109","line":125,"column":6,"nodeType":"100","endLine":125,"endColumn":61,"suggestions":"110"},{"ruleId":"98","severity":1,"message":"111","line":131,"column":6,"nodeType":"100","endLine":131,"endColumn":22,"suggestions":"112"},{"ruleId":"98","severity":1,"message":"113","line":333,"column":6,"nodeType":"100","endLine":333,"endColumn":28,"suggestions":"114"},{"ruleId":"98","severity":1,"message":"115","line":378,"column":6,"nodeType":"100","endLine":378,"endColumn":62,"suggestions":"116"},{"ruleId":"98","severity":1,"message":"117","line":415,"column":6,"nodeType":"100","endLine":415,"endColumn":47,"suggestions":"118"},{"ruleId":"98","severity":1,"message":"119","line":236,"column":5,"nodeType":"100","endLine":236,"endColumn":56,"suggestions":"120"},{"ruleId":"98","severity":1,"message":"121","line":236,"column":46,"nodeType":"122","endLine":236,"endColumn":55},"react-hooks/exhaustive-deps","React Hook useEffect has a missing dependency: 'throwConfetti'. Either include it or remove the dependency array.","ArrayExpression",["123"],"React Hook useCallback has an unnecessary dependency: 'confetti'. Either exclude it or remove the dependency array. Outer scope values like 'confetti' aren't valid dependencies because mutating them doesn't re-render the component.",["124"],"React Hook useCallback has missing dependencies: 'candyMachineV3' and 'guardLabel'. Either include them or remove the dependency array.",["125"],"@next/next/no-img-element","Do not use `<img>` element. Use `<Image />` from `next/image` instead. See: https://nextjs.org/docs/messages/no-img-element","JSXOpeningElement","React Hook React.useMemo has a missing dependency: 'candyMachineOpts.allowLists'. Either include it or remove the dependency array.",["126"],"React Hook React.useCallback has a missing dependency: 'mx'. Either include it or remove the dependency array.",["127"],"React Hook React.useEffect has missing dependencies: 'connection' and 'wallet'. Either include them or remove the dependency array.",["128"],"React Hook React.useEffect has a missing dependency: 'mx'. Either include it or remove the dependency array.",["129"],"React Hook React.useMemo has missing dependencies: 'candyMachine' and 'wallet.publicKey'. Either include them or remove the dependency array.",["130"],"React Hook useMemo has missing dependencies: 'isActive', 'limit', and 'mintCount'. Either include them or remove the dependency array.",["131"],"React Hook useMemo has a complex expression in the dependency array. Extract it to a separate variable so it can be statically checked.","UnaryExpression",{"desc":"132","fix":"133"},{"desc":"134","fix":"135"},{"desc":"136","fix":"137"},{"desc":"138","fix":"139"},{"desc":"140","fix":"141"},{"desc":"142","fix":"143"},{"desc":"144","fix":"145"},{"desc":"146","fix":"147"},{"desc":"148","fix":"149"},"Update the dependencies array to be: [mintedItems, throwConfetti]",{"range":"150","text":"151"},"Update the dependencies array to be: []",{"range":"152","text":"153"},"Update the dependencies array to be: [candyMachineV3, guardLabel, guards.burn.nfts, guards.gate.nfts, guards.payment.nfts]",{"range":"154","text":"155"},"Update the dependencies array to be: [candyMachineOpts.allowLists, wallet.publicKey]",{"range":"156","text":"157"},"Update the dependencies array to be: [candyMachineId, mx]",{"range":"158","text":"159"},"Update the dependencies array to be: [connection, mx, wallet, wallet.publicKey]",{"range":"160","text":"161"},"Update the dependencies array to be: [wallet.publicKey, nftHoldings, proofMemo, candyMachine, mx]",{"range":"162","text":"163"},"Update the dependencies array to be: [guardsAndGroups, candyMachine, wallet.publicKey, tokenHoldings, balance]",{"range":"164","text":"165"},"Update the dependencies array to be: [loading, isSoldOut, isMinting, isEnded, isActive, mintCount, limit]",{"range":"166","text":"167"},[5118,5131],"[mintedItems, throwConfetti]",[5588,5598],"[]",[6814,6843],"[candyMachineV3, guardLabel, guards.burn.nfts, guards.gate.nfts, guards.payment.nfts]",[3271,3326],"[candyMachineOpts.allowLists, wallet.publicKey]",[3507,3523],"[candyMachineId, mx]",[10886,10908],"[connection, mx, wallet, wallet.publicKey]",[12131,12187],"[wallet.publicKey, nftHoldings, proofMemo, candyMachine, mx]",[13208,13249],"[guardsAndGroups, candyMachine, wallet.publicKey, tokenHoldings, balance]",[7032,7083],"[loading, isSoldOut, isMinting, isEnded, isActive, mintCount, limit]"]